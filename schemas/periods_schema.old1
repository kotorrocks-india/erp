from __future__ import annotations
from sqlalchemy import text as sa_text
from sqlalchemy.engine import Engine
from core.schema_registry import register
import logging

log = logging.getLogger(__name__)

def _exec(conn, sql):
    conn.execute(sa_text(sql))

@register
def install_periods_schema(engine: Engine):
    """
    Complete Periods/Timegrid Schema with Division and Multi-Year Support
    
    NEW FEATURES:
    - division_code: Templates can be division-specific
    - applicable_years: Templates can apply to multiple specific years (JSON array)
    """
    with engine.begin() as conn:
        
        # ================================================================
        # 1. PERIOD KINDS (Global Period Type Definitions)
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS period_kinds (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Identity
            code TEXT NOT NULL UNIQUE,           -- e.g., 'LECTURE_50', 'STUDIO_180'
            label TEXT NOT NULL,                 -- e.g., 'Lecture - 50 min'
            
            -- Classification
            role TEXT NOT NULL CHECK (role IN (
                'teaching', 'break', 'lunch', 'assembly', 'other'
            )),
            
            -- Default Duration
            default_duration_min INTEGER NOT NULL,
            
            -- Visual Styling
            color_hex TEXT DEFAULT '#2196F3',
            icon TEXT DEFAULT 'ðŸ“š',
            
            -- Bridging Capability
            is_blockable INTEGER DEFAULT 0,      -- Can this period type be part of a multi-period block?
            
            -- Status
            active INTEGER DEFAULT 1,
            sort_order INTEGER DEFAULT 100,
            
            -- Metadata
            description TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            created_by TEXT
        )
        """)
        
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_period_kinds_code ON period_kinds(code)")
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_period_kinds_role ON period_kinds(role)")
        
        # ================================================================
        # 2. DAY TEMPLATES (Main Template Metadata)
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS day_templates (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Identification
            template_code TEXT NOT NULL,         -- e.g., 'BARCH_Y4_DIVA_STANDARD'
            template_name TEXT NOT NULL,         -- e.g., 'B.Arch Year 4 Division A Standard Day'
            
            -- Temporal Scope (AY-specific)
            ay_label TEXT NOT NULL,
            term INTEGER NOT NULL CHECK (term BETWEEN 1 AND 4),
            
            -- Organizational Scope (Hierarchy)
            degree_code TEXT NOT NULL,
            program_code TEXT,                   -- NULL = applies to all programs
            branch_code TEXT,                    -- NULL = applies to all branches
            year INTEGER CHECK (year BETWEEN 1 AND 10),  -- NULL = applies to all years (unless applicable_years is set)
            division_code TEXT,                  -- NULL = applies to all divisions, 'A'/'B'/etc = specific division
            
            -- NEW: Multi-Year Support
            applicable_years TEXT,               -- JSON array: "[1,2,3,5]" = applies to years 1,2,3,5 only
                                                -- NULL = use 'year' field logic
                                                -- If both NULL, applies to ALL years
            
            -- Status & Workflow
            status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN (
                'draft', 'published', 'archived', 'deleted'
            )),
            
            -- Configuration
            count_mode TEXT DEFAULT 'teaching_only' CHECK (count_mode IN (
                'teaching_only', 'all_slots'
            )),
            
            is_default_for_scope INTEGER DEFAULT 0,  -- One default per scope
            
            -- Versioning & Copy Tracking
            version_number INTEGER DEFAULT 1,
            copied_from_template_id INTEGER,         -- For AY rollover tracking
            copy_source_ay TEXT,                     -- Original AY if copied
            
            -- Computed Summary (denormalized for performance)
            total_slots INTEGER DEFAULT 0,
            total_teaching_slots INTEGER DEFAULT 0,
            total_minutes_all_slots INTEGER DEFAULT 0,
            total_teaching_minutes INTEGER DEFAULT 0,
            
            -- Audit
            created_by TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            updated_by TEXT,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            published_by TEXT,
            published_at DATETIME,
            
            archived_by TEXT,
            archived_at DATETIME,
            archived_reason TEXT,
            
            -- Constraints
            UNIQUE(ay_label, term, degree_code, program_code, branch_code, year, division_code, template_code),
            FOREIGN KEY (copied_from_template_id) REFERENCES day_templates(id) ON DELETE SET NULL
        )
        """)
        
        _exec(conn, """
            CREATE INDEX IF NOT EXISTS idx_day_templates_context 
            ON day_templates(ay_label, term, degree_code, program_code, branch_code, year, division_code)
        """)
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_day_templates_status ON day_templates(status)")
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_day_templates_default ON day_templates(is_default_for_scope)")
        
        # ================================================================
        # 3. DAY TEMPLATE SLOTS (Default Day Structure)
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS day_template_slots (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Parent template
            template_id INTEGER NOT NULL,
            
            -- Position
            slot_index INTEGER NOT NULL,         -- 1, 2, 3, ... (display order)
            slot_code TEXT NOT NULL,             -- 'P1', 'BREAK1', 'LUNCH', etc.
            slot_label TEXT NOT NULL,            -- 'Period 1', 'Short Break', etc.
            
            -- Period Type
            period_kind_code TEXT NOT NULL,      -- FK to period_kinds
            
            -- Duration (can override default from period_kind)
            duration_min INTEGER NOT NULL,
            
            -- Fixed Times (HH:MM format)
            fixed_start_time TEXT,               -- e.g., '08:30'
            fixed_end_time TEXT,                 -- e.g., '09:10'
            
            -- Classification (denormalized for queries)
            is_teaching_slot INTEGER DEFAULT 0,
            role TEXT,                            -- Copied from period_kind
            
            -- Block Info (for studio/long periods)
            is_block_start INTEGER DEFAULT 0,
            is_block_part INTEGER DEFAULT 0,
            block_group_id TEXT,                  -- Groups slots in same block
            
            -- Metadata
            notes TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            FOREIGN KEY (template_id) REFERENCES day_templates(id) ON DELETE CASCADE,
            FOREIGN KEY (period_kind_code) REFERENCES period_kinds(code) ON DELETE RESTRICT,
            UNIQUE(template_id, slot_index),
            UNIQUE(template_id, slot_code)
        )
        """)
        
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_template_slots_template ON day_template_slots(template_id)")
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_template_slots_kind ON day_template_slots(period_kind_code)")
        
        # ================================================================
        # 4. WEEKDAY OVERRIDES (Different structure for specific days)
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS day_template_weekday_overrides (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Parent template
            template_id INTEGER NOT NULL,
            
            -- Which day
            weekday TEXT NOT NULL CHECK (weekday IN (
                'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'
            )),
            
            -- Computed Summary
            total_slots INTEGER DEFAULT 0,
            total_teaching_slots INTEGER DEFAULT 0,
            total_minutes_all_slots INTEGER DEFAULT 0,
            total_teaching_minutes INTEGER DEFAULT 0,
            
            -- Metadata
            note TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            created_by TEXT,
            
            FOREIGN KEY (template_id) REFERENCES day_templates(id) ON DELETE CASCADE,
            UNIQUE(template_id, weekday)
        )
        """)
        
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_weekday_overrides_template ON day_template_weekday_overrides(template_id)")
        
        # ================================================================
        # 5. WEEKDAY OVERRIDE SLOTS (Periods for override days)
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS day_template_override_slots (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Parent override
            override_id INTEGER NOT NULL,
            
            -- Position (same structure as day_template_slots)
            slot_index INTEGER NOT NULL,
            slot_code TEXT NOT NULL,
            slot_label TEXT NOT NULL,
            
            period_kind_code TEXT NOT NULL,
            duration_min INTEGER NOT NULL,
            
            fixed_start_time TEXT,
            fixed_end_time TEXT,
            
            is_teaching_slot INTEGER DEFAULT 0,
            role TEXT,
            
            is_block_start INTEGER DEFAULT 0,
            is_block_part INTEGER DEFAULT 0,
            block_group_id TEXT,
            
            notes TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            FOREIGN KEY (override_id) REFERENCES day_template_weekday_overrides(id) ON DELETE CASCADE,
            FOREIGN KEY (period_kind_code) REFERENCES period_kinds(code) ON DELETE RESTRICT,
            UNIQUE(override_id, slot_index),
            UNIQUE(override_id, slot_code)
        )
        """)
        
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_override_slots_override ON day_template_override_slots(override_id)")
        
        # ================================================================
        # 6. AUDIT TRAIL
        # ================================================================
        _exec(conn, """
        CREATE TABLE IF NOT EXISTS day_template_audit (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            
            -- Template reference
            template_id INTEGER NOT NULL,
            template_code TEXT,
            
            -- Action
            action TEXT NOT NULL CHECK (action IN (
                'create', 'update', 'delete',
                'publish', 'unpublish', 'archive', 'restore',
                'copy_from_ay', 'copy_to_division',
                'add_slot', 'remove_slot', 'reorder_slots',
                'add_override', 'remove_override'
            )),
            
            -- Details
            note TEXT,
            changed_fields TEXT,                 -- JSON blob
            
            -- Actor
            actor TEXT NOT NULL,
            actor_role TEXT,
            
            -- Timing
            occurred_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            -- Source tracking
            source TEXT DEFAULT 'ui',
            correlation_id TEXT,
            
            FOREIGN KEY (template_id) REFERENCES day_templates(id) ON DELETE CASCADE
        )
        """)
        
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_template_audit_template ON day_template_audit(template_id)")
        _exec(conn, "CREATE INDEX IF NOT EXISTS idx_template_audit_action ON day_template_audit(action, occurred_at DESC)")
        
        # ================================================================
        # 7. VIEWS FOR CONVENIENCE
        # ================================================================
        
        # View: Full template with summary
        _exec(conn, "DROP VIEW IF EXISTS v_day_templates_full")
        _exec(conn, """
        CREATE VIEW v_day_templates_full AS
        SELECT 
            t.*,
            COUNT(DISTINCT s.id) as slot_count,
            COUNT(DISTINCT CASE WHEN s.is_teaching_slot = 1 THEN s.id END) as teaching_slot_count,
            COUNT(DISTINCT o.id) as override_count,
            CASE 
                WHEN t.status = 'published' THEN 'âœ… Published'
                WHEN t.status = 'draft' THEN 'ðŸ“ Draft'
                WHEN t.status = 'archived' THEN 'ðŸ“¦ Archived'
                ELSE t.status
            END as status_display
        FROM day_templates t
        LEFT JOIN day_template_slots s ON s.template_id = t.id
        LEFT JOIN day_template_weekday_overrides o ON o.template_id = t.id
        GROUP BY t.id
        """)
        
        # View: Active period kinds
        _exec(conn, "DROP VIEW IF EXISTS v_period_kinds_active")
        _exec(conn, """
        CREATE VIEW v_period_kinds_active AS
        SELECT * FROM period_kinds
        WHERE active = 1
        ORDER BY role, sort_order, label
        """)
        
        # ================================================================
        # 8. TRIGGERS FOR AUTO-COMPUTATION
        # ================================================================
        
        # Auto-update template summary on slot changes
        _exec(conn, """
        CREATE TRIGGER IF NOT EXISTS trg_recompute_template_summary_insert
        AFTER INSERT ON day_template_slots
        BEGIN
            UPDATE day_templates
            SET 
                total_slots = (
                    SELECT COUNT(*) FROM day_template_slots WHERE template_id = NEW.template_id
                ),
                total_teaching_slots = (
                    SELECT COUNT(*) FROM day_template_slots 
                    WHERE template_id = NEW.template_id AND is_teaching_slot = 1
                ),
                total_minutes_all_slots = (
                    SELECT SUM(duration_min) FROM day_template_slots WHERE template_id = NEW.template_id
                ),
                total_teaching_minutes = (
                    SELECT SUM(duration_min) FROM day_template_slots 
                    WHERE template_id = NEW.template_id AND is_teaching_slot = 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = NEW.template_id;
        END;
        """)
        
        _exec(conn, """
        CREATE TRIGGER IF NOT EXISTS trg_recompute_template_summary_update
        AFTER UPDATE ON day_template_slots
        BEGIN
            UPDATE day_templates
            SET 
                total_slots = (
                    SELECT COUNT(*) FROM day_template_slots WHERE template_id = NEW.template_id
                ),
                total_teaching_slots = (
                    SELECT COUNT(*) FROM day_template_slots 
                    WHERE template_id = NEW.template_id AND is_teaching_slot = 1
                ),
                total_minutes_all_slots = (
                    SELECT SUM(duration_min) FROM day_template_slots WHERE template_id = NEW.template_id
                ),
                total_teaching_minutes = (
                    SELECT SUM(duration_min) FROM day_template_slots 
                    WHERE template_id = NEW.template_id AND is_teaching_slot = 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = NEW.template_id;
        END;
        """)
        
        _exec(conn, """
        CREATE TRIGGER IF NOT EXISTS trg_recompute_template_summary_delete
        AFTER DELETE ON day_template_slots
        BEGIN
            UPDATE day_templates
            SET 
                total_slots = (
                    SELECT COUNT(*) FROM day_template_slots WHERE template_id = OLD.template_id
                ),
                total_teaching_slots = (
                    SELECT COUNT(*) FROM day_template_slots 
                    WHERE template_id = OLD.template_id AND is_teaching_slot = 1
                ),
                total_minutes_all_slots = (
                    SELECT COALESCE(SUM(duration_min), 0) FROM day_template_slots WHERE template_id = OLD.template_id
                ),
                total_teaching_minutes = (
                    SELECT COALESCE(SUM(duration_min), 0) FROM day_template_slots 
                    WHERE template_id = OLD.template_id AND is_teaching_slot = 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = OLD.template_id;
        END;
        """)
        
        # ================================================================
        # 9. SEED DATA: Default Period Kinds
        # ================================================================
        
        # Check if period_kinds is empty
        count = conn.execute(sa_text("SELECT COUNT(*) FROM period_kinds")).fetchone()[0]
        
        if count == 0:
            log.info("Seeding default period kinds...")
            
            default_kinds = [
                ('LECTURE_40', 'Lecture - 40 min', 'teaching', 40, '#2196F3', 'ðŸ“š', 0),
                ('LECTURE_50', 'Lecture - 50 min', 'teaching', 50, '#1E88E5', 'ðŸ“š', 0),
                ('LECTURE_60', 'Lecture - 60 min', 'teaching', 60, '#1976D2', 'ðŸ“š', 0),
                ('STUDIO_120', 'Studio - 2 hours', 'teaching', 120, '#9C27B0', 'ðŸŽ¨', 1),
                ('STUDIO_180', 'Studio - 3 hours', 'teaching', 180, '#8E24AA', 'ðŸŽ¨', 1),
                ('STUDIO_240', 'Studio - 4 hours', 'teaching', 240, '#7B1FA2', 'ðŸŽ¨', 1),
                ('PRACTICAL_90', 'Practical - 90 min', 'teaching', 90, '#FF9800', 'ðŸ”¬', 0),
                ('PRACTICAL_120', 'Practical - 2 hours', 'teaching', 120, '#F57C00', 'ðŸ”¬', 0),
                ('THEORY_50', 'Theory - 50 min', 'teaching', 50, '#4CAF50', 'ðŸ“–', 0),
                ('THEORY_60', 'Theory - 60 min', 'teaching', 60, '#43A047', 'ðŸ“–', 0),
                ('BREAK_10', 'Short Break - 10 min', 'break', 10, '#FFD54F', 'â˜•', 0),
                ('BREAK_15', 'Short Break - 15 min', 'break', 15, '#FFC107', 'â˜•', 0),
                ('BREAK_20', 'Long Break - 20 min', 'break', 20, '#FFB300', 'â˜•', 0),
                ('LUNCH_30', 'Lunch - 30 min', 'lunch', 30, '#FF5722', 'ðŸ½ï¸', 0),
                ('LUNCH_45', 'Lunch - 45 min', 'lunch', 45, '#F4511E', 'ðŸ½ï¸', 0),
                ('LUNCH_60', 'Lunch - 60 min', 'lunch', 60, '#E64A19', 'ðŸ½ï¸', 0),
                ('ASSEMBLY_20', 'Assembly - 20 min', 'assembly', 20, '#607D8B', 'ðŸŽ¤', 0),
                ('ASSEMBLY_30', 'Assembly - 30 min', 'assembly', 30, '#546E7A', 'ðŸŽ¤', 0),
                ('GENERAL_30', 'General - 30 min', 'other', 30, '#9E9E9E', 'âš™ï¸', 0),
                ('GENERAL_45', 'General - 45 min', 'other', 45, '#757575', 'âš™ï¸', 0),
            ]
            
            for code, label, role, duration, color, icon, blockable in default_kinds:
                conn.execute(sa_text("""
                    INSERT INTO period_kinds 
                    (code, label, role, default_duration_min, color_hex, icon, is_blockable, created_by)
                    VALUES (:code, :label, :role, :duration, :color, :icon, :blockable, 'system')
                """), {
                    'code': code, 'label': label, 'role': role, 
                    'duration': duration, 'color': color, 'icon': icon, 'blockable': blockable
                })
            
            log.info(f"âœ… Seeded {len(default_kinds)} default period kinds")
    
    log.info("âœ… Periods/Timegrid schema installed successfully with division and multi-year support")


# ================================================================
# UTILITY FUNCTIONS
# ================================================================

def get_template_for_context(engine: Engine, ay_label: str, term: int, 
                             degree_code: str, program_code: str = None,
                             branch_code: str = None, year: int = None,
                             division_code: str = None) -> dict:
    """
    Get the most specific template for a given context.
    
    New features:
    - Supports division_code matching
    - Supports applicable_years JSON array matching
    
    Specificity Priority (highest to lowest):
    1. Division + Branch + Program + Year
    2. Division + Branch + Year
    3. Division + Year
    4. Year
    5. Division (applies to all years)
    6. Degree only (applies to all)
    
    Returns:
        dict with template data or None if not found
    """
    import json
    
    with engine.connect() as conn:
        # Fetch all matching templates
        result = conn.execute(sa_text("""
            SELECT 
                t.*,
                -- Specificity score: more specific = higher score
                (CASE WHEN t.year IS NOT NULL OR t.applicable_years IS NOT NULL THEN 1 ELSE 0 END +
                 CASE WHEN t.division_code IS NOT NULL THEN 1 ELSE 0 END +
                 CASE WHEN t.branch_code IS NOT NULL THEN 1 ELSE 0 END +
                 CASE WHEN t.program_code IS NOT NULL THEN 1 ELSE 0 END) as specificity_score
            FROM day_templates t
            WHERE t.ay_label = :ay
              AND t.term = :term
              AND t.degree_code = :degree
              AND (:prog IS NULL OR t.program_code = :prog OR t.program_code IS NULL)
              AND (:branch IS NULL OR t.branch_code = :branch OR t.branch_code IS NULL)
              AND (:div IS NULL OR t.division_code = :div OR t.division_code IS NULL)
              AND t.status = 'published'
            ORDER BY specificity_score DESC, t.published_at DESC
        """), {
            'ay': ay_label,
            'term': term,
            'degree': degree_code,
            'prog': program_code,
            'branch': branch_code,
            'div': division_code
        }).fetchall()
        
        if not result:
            return None
        
        # Filter by year applicability (if year is provided)
        if year is not None:
            for row in result:
                template_year = row[8]  # year column
                applicable_years_json = row[10]  # applicable_years column
                
                # Check if this template applies to the requested year
                if applicable_years_json:
                    # Template has specific years list
                    try:
                        applicable_years = json.loads(applicable_years_json)
                        if year in applicable_years:
                            return dict(row._mapping)
                    except (json.JSONDecodeError, TypeError):
                        # Invalid JSON, skip this template
                        continue
                elif template_year is not None:
                    # Template has single year
                    if template_year == year:
                        return dict(row._mapping)
                else:
                    # Template applies to all years (both NULL)
                    return dict(row._mapping)
        else:
            # No year filter, return most specific
            return dict(result[0]._mapping)
        
        return None


def check_year_applicability(template_year: int, applicable_years_json: str, target_year: int) -> bool:
    """
    Check if a template applies to a specific year.
    
    Logic:
    - If applicable_years is set: target_year must be in the JSON array
    - Else if template_year is set: must match exactly
    - Else (both NULL): applies to all years
    
    Args:
        template_year: Single year value from template (or None)
        applicable_years_json: JSON array string "[1,2,3]" (or None)
        target_year: Year to check
    
    Returns:
        True if template applies to target_year
    """
    import json
    
    if applicable_years_json:
        try:
            applicable_years = json.loads(applicable_years_json)
            return target_year in applicable_years
        except (json.JSONDecodeError, TypeError):
            return False
    elif template_year is not None:
        return template_year == target_year
    else:
        # Both NULL = applies to all years
        return True
